// BBitmap-like class
//
// see License at the end of file

#include "Bitmap.h"
#include "GraphicDefs.h"
#include "Region.h"

#include <gdk-pixbuf/gdk-pixbuf.h>
#include <malloc.h>

FBitmap::FBitmap(FRect rect, color_space , bool, bool)
	:	fBounds(rect),
		fPixbuf(NULL)
{
}

FBitmap::~FBitmap()
{
	if (fPixbuf)
		gdk_pixbuf_unref(fPixbuf);
}


FRect 
FBitmap::Bounds() const
{
	return fBounds;
}

static void
FreeBits(uchar *pixels, void *)
{
	free(pixels);
}

struct RGBAPixel {
	uchar r;
	uchar g;
	uchar b;
	uchar a;
};

// auto-generated 8-bit color map values

static const uchar kBeOSColormap[] = {
	0x00,0x00,0x00,0xff, 0x08,0x08,0x08,0xff, 0x10,0x10,0x10,0xff, 0x18,0x18,0x18,0xff, 
	0x20,0x20,0x20,0xff, 0x28,0x28,0x28,0xff, 0x30,0x30,0x30,0xff, 0x38,0x38,0x38,0xff, 
	0x40,0x40,0x40,0xff, 0x48,0x48,0x48,0xff, 0x50,0x50,0x50,0xff, 0x58,0x58,0x58,0xff, 
	0x60,0x60,0x60,0xff, 0x68,0x68,0x68,0xff, 0x70,0x70,0x70,0xff, 0x78,0x78,0x78,0xff, 
	0x80,0x80,0x80,0xff, 0x88,0x88,0x88,0xff, 0x90,0x90,0x90,0xff, 0x98,0x98,0x98,0xff, 
	0xa0,0xa0,0xa0,0xff, 0xa8,0xa8,0xa8,0xff, 0xb0,0xb0,0xb0,0xff, 0xb8,0xb8,0xb8,0xff, 
	0xc0,0xc0,0xc0,0xff, 0xc8,0xc8,0xc8,0xff, 0xd0,0xd0,0xd0,0xff, 0xd8,0xd8,0xd8,0xff, 
	0xe0,0xe0,0xe0,0xff, 0xe8,0xe8,0xe8,0xff, 0xf0,0xf0,0xf0,0xff, 0xf8,0xf8,0xf8,0xff, 
	0x00,0x00,0xff,0xff, 0x00,0x00,0xe5,0xff, 0x00,0x00,0xcc,0xff, 0x00,0x00,0xb3,0xff, 
	0x00,0x00,0x9a,0xff, 0x00,0x00,0x81,0xff, 0x00,0x00,0x69,0xff, 0x00,0x00,0x50,0xff, 
	0x00,0x00,0x37,0xff, 0x00,0x00,0x1e,0xff, 0xff,0x00,0x00,0xff, 0xe4,0x00,0x00,0xff, 
	0xcb,0x00,0x00,0xff, 0xb2,0x00,0x00,0xff, 0x99,0x00,0x00,0xff, 0x80,0x00,0x00,0xff, 
	0x69,0x00,0x00,0xff, 0x50,0x00,0x00,0xff, 0x37,0x00,0x00,0xff, 0x1e,0x00,0x00,0xff, 
	0x00,0xff,0x00,0xff, 0x00,0xe4,0x00,0xff, 0x00,0xcb,0x00,0xff, 0x00,0xb2,0x00,0xff, 
	0x00,0x99,0x00,0xff, 0x00,0x80,0x00,0xff, 0x00,0x69,0x00,0xff, 0x00,0x50,0x00,0xff, 
	0x00,0x37,0x00,0xff, 0x00,0x1e,0x00,0xff, 0x00,0x98,0x33,0xff, 0xff,0xff,0xff,0xff, 
	0xcb,0xff,0xff,0xff, 0xcb,0xff,0xcb,0xff, 0xcb,0xff,0x98,0xff, 0xcb,0xff,0x66,0xff, 
	0xcb,0xff,0x33,0xff, 0xcb,0xff,0x00,0xff, 0x98,0xff,0xff,0xff, 0x98,0xff,0xcb,0xff, 
	0x98,0xff,0x98,0xff, 0x98,0xff,0x66,0xff, 0x98,0xff,0x33,0xff, 0x98,0xff,0x00,0xff, 
	0x66,0xff,0xff,0xff, 0x66,0xff,0xcb,0xff, 0x66,0xff,0x98,0xff, 0x66,0xff,0x66,0xff, 
	0x66,0xff,0x33,0xff, 0x66,0xff,0x00,0xff, 0x33,0xff,0xff,0xff, 0x33,0xff,0xcb,0xff, 
	0x33,0xff,0x98,0xff, 0x33,0xff,0x66,0xff, 0x33,0xff,0x33,0xff, 0x33,0xff,0x00,0xff, 
	0xff,0x98,0xff,0xff, 0xff,0x98,0xcb,0xff, 0xff,0x98,0x98,0xff, 0xff,0x98,0x66,0xff, 
	0xff,0x98,0x33,0xff, 0xff,0x98,0x00,0xff, 0x00,0x66,0xff,0xff, 0x00,0x66,0xcb,0xff, 
	0xcb,0xcb,0xff,0xff, 0xcb,0xcb,0xcb,0xff, 0xcb,0xcb,0x98,0xff, 0xcb,0xcb,0x66,0xff, 
	0xcb,0xcb,0x33,0xff, 0xcb,0xcb,0x00,0xff, 0x98,0xcb,0xff,0xff, 0x98,0xcb,0xcb,0xff, 
	0x98,0xcb,0x98,0xff, 0x98,0xcb,0x66,0xff, 0x98,0xcb,0x33,0xff, 0x98,0xcb,0x00,0xff, 
	0x66,0xcb,0xff,0xff, 0x66,0xcb,0xcb,0xff, 0x66,0xcb,0x98,0xff, 0x66,0xcb,0x66,0xff, 
	0x66,0xcb,0x33,0xff, 0x66,0xcb,0x00,0xff, 0x33,0xcb,0xff,0xff, 0x33,0xcb,0xcb,0xff, 
	0x33,0xcb,0x98,0xff, 0x33,0xcb,0x66,0xff, 0x33,0xcb,0x33,0xff, 0x33,0xcb,0x00,0xff, 
	0xff,0x66,0xff,0xff, 0xff,0x66,0xcb,0xff, 0xff,0x66,0x98,0xff, 0xff,0x66,0x66,0xff, 
	0xff,0x66,0x33,0xff, 0xff,0x66,0x00,0xff, 0x00,0x66,0x98,0xff, 0x00,0x66,0x66,0xff, 
	0xcb,0x98,0xff,0xff, 0xcb,0x98,0xcb,0xff, 0xcb,0x98,0x98,0xff, 0xcb,0x98,0x66,0xff, 
	0xcb,0x98,0x33,0xff, 0xcb,0x98,0x00,0xff, 0x98,0x98,0xff,0xff, 0x98,0x98,0xcb,0xff, 
	0x98,0x98,0x98,0xff, 0x98,0x98,0x66,0xff, 0x98,0x98,0x33,0xff, 0x98,0x98,0x00,0xff, 
	0x66,0x98,0xff,0xff, 0x66,0x98,0xcb,0xff, 0x66,0x98,0x98,0xff, 0x66,0x98,0x66,0xff, 
	0x66,0x98,0x33,0xff, 0x66,0x98,0x00,0xff, 0x33,0x98,0xff,0xff, 0x33,0x98,0xcb,0xff, 
	0x33,0x98,0x98,0xff, 0x33,0x98,0x66,0xff, 0x33,0x98,0x33,0xff, 0x33,0x98,0x00,0xff, 
	0xe6,0x86,0x00,0xff, 0xff,0x33,0xcb,0xff, 0xff,0x33,0x98,0xff, 0xff,0x33,0x66,0xff, 
	0xff,0x33,0x33,0xff, 0xff,0x33,0x00,0xff, 0x00,0x66,0x33,0xff, 0x00,0x66,0x00,0xff, 
	0xcb,0x66,0xff,0xff, 0xcb,0x66,0xcb,0xff, 0xcb,0x66,0x98,0xff, 0xcb,0x66,0x66,0xff, 
	0xcb,0x66,0x33,0xff, 0xcb,0x66,0x00,0xff, 0x98,0x66,0xff,0xff, 0x98,0x66,0xcb,0xff, 
	0x98,0x66,0x98,0xff, 0x98,0x66,0x66,0xff, 0x98,0x66,0x33,0xff, 0x98,0x66,0x00,0xff, 
	0x66,0x66,0xff,0xff, 0x66,0x66,0xcb,0xff, 0x66,0x66,0x98,0xff, 0x66,0x66,0x66,0xff, 
	0x66,0x66,0x33,0xff, 0x66,0x66,0x00,0xff, 0x33,0x66,0xff,0xff, 0x33,0x66,0xcb,0xff, 
	0x33,0x66,0x98,0xff, 0x33,0x66,0x66,0xff, 0x33,0x66,0x33,0xff, 0x33,0x66,0x00,0xff, 
	0xff,0x00,0xff,0xff, 0xff,0x00,0xcb,0xff, 0xff,0x00,0x98,0xff, 0xff,0x00,0x66,0xff, 
	0xff,0x00,0x33,0xff, 0xff,0xaf,0x13,0xff, 0x00,0x33,0xff,0xff, 0x00,0x33,0xcb,0xff, 
	0xcb,0x33,0xff,0xff, 0xcb,0x33,0xcb,0xff, 0xcb,0x33,0x98,0xff, 0xcb,0x33,0x66,0xff, 
	0xcb,0x33,0x33,0xff, 0xcb,0x33,0x00,0xff, 0x98,0x33,0xff,0xff, 0x98,0x33,0xcb,0xff, 
	0x98,0x33,0x98,0xff, 0x98,0x33,0x66,0xff, 0x98,0x33,0x33,0xff, 0x98,0x33,0x00,0xff, 
	0x66,0x33,0xff,0xff, 0x66,0x33,0xcb,0xff, 0x66,0x33,0x98,0xff, 0x66,0x33,0x66,0xff, 
	0x66,0x33,0x33,0xff, 0x66,0x33,0x00,0xff, 0x33,0x33,0xff,0xff, 0x33,0x33,0xcb,0xff, 
	0x33,0x33,0x98,0xff, 0x33,0x33,0x66,0xff, 0x33,0x33,0x33,0xff, 0x33,0x33,0x00,0xff, 
	0xff,0xcb,0x66,0xff, 0xff,0xcb,0x98,0xff, 0xff,0xcb,0xcb,0xff, 0xff,0xcb,0xff,0xff, 
	0x00,0x33,0x98,0xff, 0x00,0x33,0x66,0xff, 0x00,0x33,0x33,0xff, 0x00,0x33,0x00,0xff, 
	0xcb,0x00,0xff,0xff, 0xcb,0x00,0xcb,0xff, 0xcb,0x00,0x98,0xff, 0xcb,0x00,0x66,0xff, 
	0xcb,0x00,0x33,0xff, 0xff,0xe3,0x46,0xff, 0x98,0x00,0xff,0xff, 0x98,0x00,0xcb,0xff, 
	0x98,0x00,0x98,0xff, 0x98,0x00,0x66,0xff, 0x98,0x00,0x33,0xff, 0x98,0x00,0x00,0xff, 
	0x66,0x00,0xff,0xff, 0x66,0x00,0xcb,0xff, 0x66,0x00,0x98,0xff, 0x66,0x00,0x66,0xff, 
	0x66,0x00,0x33,0xff, 0x66,0x00,0x00,0xff, 0x33,0x00,0xff,0xff, 0x33,0x00,0xcb,0xff, 
	0x33,0x00,0x98,0xff, 0x33,0x00,0x66,0xff, 0x33,0x00,0x33,0xff, 0x33,0x00,0x00,0xff, 
	0xff,0xcb,0x33,0xff, 0xff,0xcb,0x00,0xff, 0xff,0xff,0x00,0xff, 0xff,0xff,0x33,0xff, 
	0xff,0xff,0x66,0xff, 0xff,0xff,0x98,0xff, 0xff,0xff,0xcb,0xff, 0x00,0x00,0x00,0x00
};


inline void
ConvertFrom8Bit(RGBAPixel *pixel, const uchar *&data)
{
	const uchar *indexedColor = &kBeOSColormap[*data * 4];
	pixel->r = indexedColor[0];
	pixel->g = indexedColor[1];
	pixel->b = indexedColor[2];
	pixel->a = indexedColor[3];
	data++;
}
 
inline void
ConvertFrom24Bit(RGBAPixel *pixel, const uchar *&data)
{
	pixel->r = *data++;
	pixel->g = *data++;
	pixel->b = *data++;
	pixel->a = 255;
}
 
inline void
ConvertFrom32Bit(RGBAPixel *pixel, const uchar *&data)
{
	pixel->r = *data++;
	pixel->g = *data++;
	pixel->b = *data++;
	pixel->a = *data++;
}
 
inline void
EachPixel(void (*func) (RGBAPixel *pixel, const uchar *&data), uchar *pixels,
	int32 rowstride, int32 width, int32 height, const uchar *&data)
{
	for (int32 row = 0; row < height; row++) {
		for (int32 column = 0; column < width; column++)
			(func)(((RGBAPixel *)pixels) + column, data);
		pixels += rowstride;
	}
}
 
void 
FBitmap::AddChild(FView *)
{
	// remove this?
	ASSERT(!"not supported on libgnobe");
}

bool 
FBitmap::RemoveChild(FView *)
{
	// remove this?
	ASSERT(!"not supported on libgnobe");
	return false;
}

void 
FBitmap::SetBits(const uchar *bits, int32, int32, color_space color_depth)
{
	if (fPixbuf)
		gdk_pixbuf_unref(fPixbuf);

	int32 width = (int32)fBounds.Width() + 1;
	int32 height = (int32)fBounds.Height() + 1;
	
	int32 rowstride = ((width * 4) + 3) & -4;
	uchar *pixels = (uchar *)malloc(rowstride * height);

	switch (color_depth) {
		case B_CMAP8:
			EachPixel(&ConvertFrom8Bit, pixels, rowstride, width, 
				height, bits);
			break;
		case B_RGB24:
			EachPixel(&ConvertFrom24Bit, pixels, rowstride, width, 
				height, bits);
			break;
		case B_RGB32:
			EachPixel(&ConvertFrom32Bit, pixels, rowstride, width, 
				height, bits);
			break;
		default:
			ASSERT(!"implement me");
			break;
	}

	fPixbuf = gdk_pixbuf_new_from_data (pixels,
		GDK_COLORSPACE_RGB, true, 8, width, height, rowstride, &FreeBits, NULL);
}

static void
GdkPixbufClipRect(GdkPixbuf *pixbuf, GdkRectangle rect)
{
	// set alpha 0 to all pixels outside the clip rect
	ASSERT(gdk_pixbuf_get_has_alpha(pixbuf));
	ASSERT(gdk_pixbuf_get_n_channels(pixbuf) == 4);

	int32 width = gdk_pixbuf_get_width(pixbuf);
	int32 height = gdk_pixbuf_get_height(pixbuf);
	
	for (int32 y = 0; y < height; y++) {

		char *destPixels = (char *)gdk_pixbuf_get_pixels(pixbuf)
			+ gdk_pixbuf_get_rowstride(pixbuf) * y;
			
		for (int32 x = 0; x < width; x++) {
			destPixels += 3;
			if (y < rect.y || y > rect.y + rect.height
				|| x < rect.x || x > rect.x + rect.width)
				*destPixels = 0;
			destPixels++;
		}
	}
}

void 
FBitmap::Draw(FView *view, const FRegion *region, FRect from, FRect to) const
{
	if (!PixBuf())
		return;

	if (from.right > fBounds.right + 1) {
		from.right = fBounds.right + 1;
	}

	if (from.bottom > fBounds.bottom + 1) {
		from.bottom = fBounds.bottom + 1;
	}

	if (to.Width() > fBounds.Width() + 1) {
		to.right = to.left + fBounds.right - fBounds.left + 1;
	}

	if (to.Height() > fBounds.Height() + 1) {
		to.bottom = to.top + fBounds.bottom - fBounds.top + 1;
	}

	if (region) {
		GdkPixbuf *clippedPixbuf = gdk_pixbuf_copy(PixBuf());
		FRect clipRect(region->Frame());
		clipRect.OffsetBy(from.LeftTop() - to.LeftTop());
		GdkPixbufClipRect(clippedPixbuf, clipRect.GdkRect());

		gdk_pixbuf_render_to_drawable_alpha(clippedPixbuf,
			view->AsGtkWidget()->window, 
			(int32)from.left, (int32)from.top, (int32)to.left, (int32)to.top,
			(int32)to.Width(), (int32)to.Height(), 
			GDK_PIXBUF_ALPHA_BILEVEL, 128,
			GDK_RGB_DITHER_MAX, 0, 0);
		gdk_pixbuf_unref(clippedPixbuf);
	} else
		gdk_pixbuf_render_to_drawable_alpha(PixBuf(),
			view->AsGtkWidget()->window, 
			(int32)from.left, (int32)from.top, (int32)to.left, (int32)to.top,
			(int32)to.Width(), (int32)to.Height(), 
			GDK_PIXBUF_ALPHA_BILEVEL, 128,
			GDK_RGB_DITHER_MAX, 0, 0);
}


/*
License

Terms and Conditions

Copyright (c) 1999-2001, Pavel Cisler

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met: 

Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer. 

Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution. 

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF TITLE,
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF, OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE. 
*/
